# Cool code cleanup from-scratch project initialization

This project directory is empty. The goal is to create a new project here that uses AI to profile a codebase and clean it up.

The program is run as a CLI tool that users can invoke after cloning the project from git.

Code cleanup options can be enabled/disabled via CLI parameters, a configuration, and can be toggled on/off while running the CLI during one of the initial setup steps.

For profiling the code, we will only profile API routes. Down the road, we will add support for frontend code profiling.

Each screen in the CLI application should include the step name, description of the step, and should have the same layout.

The application can be run with "ccc profile" to run profile mode, or "ccc cleanup" to run cleanup mode.

Cool Code Cleanup can be run with "ccc configure" to set the OpenAI key and model to use for code analysis and modification.

## Profiling mode application flow:

### Functionality

Profiling mode runs the application, profiles code usage, then removes unused code (functions, types, variables, etc.)


### Configuration options
- Routes to ignore
- Routes to include
- Add dependency route short-circuiting
- Ask for permission to modify each file, or modify files without asking for permission

### Steps
- User starts CLI with optional parameters.
- Step 1a: Profiling options
  - On this screen, CLI displays code cleanup settings loaded from parameters, env values, and then the configuration file JSON. Each option shows where it was sourced from (parameter, env value, configuration). If an option is set in multiple places (i.e. parameter and env value) the loaded order of the options is shown in an arrow list (i.e. ).
  - The user is able to the options toggle them on/off.
  - User then is able to accept and proceed, or cancel.
- AI then performs codebase analysis and finds all API routes that can be invoked.
- Once the AI has found all routes that could be run, the AI then also determines if certain routes need to be run in order, i.e. if there is route dependency and notifies the user of the route dependencies. If none are detected, the CLI outputs "No route dependencies detected. Proceed to the next step?"
  - A dependency route example would be one where authentication must be run first, then the enabled route that requires authentication can be run using the token generated by the authentication route.
  - If a dependency route is toggled off in the previous step, for each dependency route that is needed to run the enabled routes, the AI outputs a list of the dependency routes that were toggled off that must be enabled for the profiling to work, and the user can accept and enable them or quit.
  - If a route requires external services that must be interacted with for the route to work, the AI offers to add an environment variable to short-circuit them - CoolCodeCleanupShortCircuit=true
    - This parameter can be used to make authenticated routes / payment routes / etc. easier to work with in a development environment and avoid unexpected and undesirable external service invocation
      - Examples of short-circuiting that the Cool Code Cleanup short-circuit env value can facilitate:
        - Skip email checks
        - Skip phone number checks
        - Skip OTP checks
        - Skip invoking payment processing
        - Short-circuit directly to token creation / payment success or fail (in these examples)
- After this operation is completed, the CLI proceeds to the next step.
- Step 1b: Dependency route short circuiting enhancement
  - This step is only run if dependency routes are detected.
  - The user is told that some dependency routes hit external services and need to include short-circuit logic so they can be profiled.
  - If the CoolCodeCleanup configuration already includes an env value for short-circuiting, or if a common short-circuit env value is detected in the code already, the next sub-step is skipped
  - Substep A: Name the short-circuit env value
    - This step is only shown if no short-circuit env value is set in the configuration, CLI parameters, or env values already.
    - The user is asked to give the name of the environment variable they want to proceed with including the short-circuit logic in the code.
      - If they accept, the CLI asks for the following settings
        - Env value to use for short-circuiting - default is CoolCodeCleanupShortCircuit.
        - Whether they want their env file updated to include the env value = true
        - Whether they want to add this value to the CoolCodeCleanup run configuration for this project
    - If they accept this, the CLI tracks this to make sure to enable that env value before profiling the routes.
  - Substep B: Update dependency routes that need short-circuiting 
    - The user is shown an interactive list of the dependency routes that do not include short-circuiting, but need it.
    - The user can toggle routes to add short-circuiting to on/off.
- Step 2: Enable/disable routes to profile
  - The discovered routes are shown in an interactive list.
  - Each route displays the list of dependency routes (if any) under it.
  - The user is able to toggle discovered routes to profile on/off.
    - If a route has a dependency route, the user is prevented from disabling it, and the CLI explains that the dependency route must be disabled first to disable the currently selected route.
  - User then is able to accept and proceed, or cancel.
- Step 3: Parameter analysis
  - The AI determines for each route a set of parameters to test with them
    - Valid parameters that would cause the code paths of each service to be run
    - Invalid parameters that would invoke error conditions
  - User then is able to accept and proceed, or cancel.
- Step 4: Begin profiling
  - The AI now has all the information it needs to profile the codebase for cleanup opportunities.
  - It begins by invoking dependency routes, and then the routes that can be run after the dependency routes.
  - Each invocation of each route + the parameters used on that invocation is output to the terminal including a success checkmark once running the route is complete.
  - Once profiling is complete, the application proceeds to the next step
- Step 3: Code cleanup
  - The application outputs a list of files that can be cleaned up to remove unused code
    - Under each file, a list of changes is shown explaining what can be cleaned up (i.e. remove this function from lines A-B, remove this variable on line Y)
  - User then is able to accept and proceed, or cancel.
  - If the user accepts, the AI performs code cleanup on the codebase and modifies files based on what has been found via profiling.
- Final step, the AI offers to create a new git branch and commit the changes to the branch.

## Cleanup mode application flow

## Functionality

Cleanup mode does code analysis, offers solutions to clean up the code, then modifies the code based on the analysis and user interaction.

### Configuration options

- Remove redundant guards
- Refactor code to follow DRY principles
- Harden code with better error handling
- Gate features behind environment variables
- Split up functions into reusable pieces
- Standardize inconsistent naming styles
- Simpify complex logic while retaining functionality, potentially splitting functions up into sub-functions
- Detect expensive functions and offer ideas to improve performance
- Ask for permission to modify each file, or modify files without asking for permission

### Steps
- Step 1: Codebase analysis
  - The CLI pulls in the Cool Cleanup Settings options from the CLI parameters, env variables, and configuration settings JSON. 
  - The user is shown a list of settings to toggle on/off - refer to the "Cleanup mode (options)" for the options that the user can toggle.
  - User then is able to accept and proceed, or cancel.
- Step 2: Code cleanup
  - The AI analyzes the codebase.
  - Once analysis is complete, the AI goes through each file and modifies it.
- Final step, the AI offers to create a new git branch and commit the changes to the branch.

## Your task

Create a spec for this project that we can create a task list from.

## Questions

Ask me any clarifying questions so we are aligned on the program requirements and how it should run and I will answer them.